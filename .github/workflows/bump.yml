# .github/workflows/bump.yml

#######################################################
# Version Bump Workflow
#
# This workflow bumps the version of a project, optionally within a specified folder.
# It can be triggered manually or called from other workflows.
# It supports skipping the bump process based on commit messages.
# It requires a GitHub Personal Access Token (GH_PAT_TOKEN) with repo permissions.
#######################################################

name: 'Version Bump'

on:
    workflow_dispatch:
        inputs:
            commit_message:
                description: 'The commit message to check for skip directives'
                required: true
                type: string
                default: 'Manual version bump'
            folder:
                description: 'Folder to bump version in (optional)'
                required: false
                type: string
            skip-tag:
                description: 'Skip creating a git tag'
                required: false
                type: boolean
                default: false
            skip-push:
                description: 'Skip pushing changes'
                required: false
                type: boolean
                default: true

    workflow_call:
        inputs:
            commit_message:
                description: 'The commit message to check for skip directives'
                required: true
                type: string
            folder:
                description: 'Folder to bump version in (optional)'
                required: false
                type: string
            skip-tag:
                description: 'Skip creating a git tag'
                required: false
                type: boolean
                default: false
            skip-push:
                description: 'Skip pushing changes'
                required: false
                type: boolean
                default: true
        outputs:
            newTag:
                description: "The new version tag"
                value: ${{ jobs.bump.outputs.newTag }}

jobs:
    bump:
        name: 'Bump Version'
        runs-on: ubuntu-latest
        if: ${{ !contains(inputs.commit_message, '#skip-bump') }}
        outputs:
            newTag: ${{ steps.version-bump.outputs.newTag }}
        steps:

            -   name: 'Setup Git Auth'
                run: |
                    git config --global user.name "github-actions[bot]"
                    git config --global user.email "github-actions[bot]@users.noreply.github.com"

            -   name: 'Checkout'
                uses: actions/checkout@v4
                with:
                    # This is required to allow the bump action to push the new tag
                    # and commit back to the repository.
                    token: ${{ secrets.GH_PAT_TOKEN }}
                    fetch-depth: 1  # Shallow checkout for better performance
                    persist-credentials: true

            -   name: 'Fetch tags'
                run: |
                    git fetch --tags --depth=1
            
            -   name: 'Check Token and Fallback'
                run: |
                    echo "Testing GH_PAT_TOKEN token..."
                    if curl -s -f -H "Authorization: token $GH_PAT_TOKEN" https://api.github.com/user > /dev/null; then
                        echo "‚úÖ GH_PAT token is valid"
                        echo "AUTH_TOKEN=$GH_PAT_TOKEN" >> $GITHUB_ENV
                    else
                        echo "‚ùå GH_PAT_TOKEN token is invalid, falling back to GITHUB_TOKEN"
                        echo "AUTH_TOKEN=$GITHUB_TOKEN" >> $GITHUB_ENV
                        
                        # Test GITHUB_TOKEN
                        if curl -s -f -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/user > /dev/null; then
                            echo "‚úÖ GITHUB_TOKEN is valid"
                        else
                            echo "‚ùå GITHUB_TOKEN is also invalid"
                        fi
                    fi
                env:
                    GH_PAT_TOKEN: ${{ secrets.GH_PAT_TOKEN }}
                    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}


            -   name: 'Version Bump'
                id: version-bump
                run: |
                    node << 'EOF'
                    const fs = require('fs');
                    const path = require('path');

                    const commitMessage = process.env.COMMIT_MESSAGE;
                    const folder = process.env.FOLDER || '';

                    if (!commitMessage) {
                        console.error('‚ùå Error: Commit message is required');
                        process.exit(1);
                    }

                    const majorWording = (process.env.MAJOR_WORDING || 'major,breaking').split(',').map(w => w.trim().toLowerCase());
                    const minorWording = (process.env.MINOR_WORDING || 'feature,feat').split(',').map(w => w.trim().toLowerCase());
                    const patchWording = (process.env.PATCH_WORDING || 'patch,fixes,fix,misc,docs,refactor').split(',').map(w => w.trim().toLowerCase());

                    function determineBumpType(message) {
                        const lowerMessage = message.toLowerCase();
                        for (const word of majorWording) {
                            if (lowerMessage.includes(word)) return 'major';
                        }
                        for (const word of minorWording) {
                            if (lowerMessage.includes(word)) return 'minor';
                        }
                        for (const word of patchWording) {
                            if (lowerMessage.includes(word)) return 'patch';
                        }
                        return 'patch';
                    }

                    function bumpVersion(version, bumpType) {
                        const parts = version.split('.').map(Number);
                        if (parts.length !== 3 || parts.some(isNaN)) {
                            throw new Error(`Invalid version format: ${version}`);
                        }
                        let [major, minor, patch] = parts;
                        switch (bumpType) {
                            case 'major':
                                major += 1;
                                minor = 0;
                                patch = 0;
                                break;
                            case 'minor':
                                minor += 1;
                                patch = 0;
                                break;
                            case 'patch':
                                patch += 1;
                                break;
                        }
                        return `${major}.${minor}.${patch}`;
                    }

                    try {
                        const packageJsonPath = folder
                            ? path.join(process.cwd(), folder, 'package.json')
                            : path.join(process.cwd(), 'package.json');

                        console.log(`üì¶ Reading package.json from: ${packageJsonPath}`);

                        if (!fs.existsSync(packageJsonPath)) {
                            console.error(`‚ùå Error: package.json not found at ${packageJsonPath}`);
                            process.exit(1);
                        }

                        const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
                        const currentVersion = packageJson.version;

                        if (!currentVersion) {
                            console.error('‚ùå Error: No version field found in package.json');
                            process.exit(1);
                        }

                        console.log(`üìå Current version: ${currentVersion}`);
                        console.log(`üí¨ Commit message: ${commitMessage}`);

                        const bumpType = determineBumpType(commitMessage);
                        console.log(`üîº Bump type: ${bumpType}`);

                        const newVersion = bumpVersion(currentVersion, bumpType);
                        console.log(`‚ú® New version: ${newVersion}`);

                        packageJson.version = newVersion;
                        fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2) + '\n', 'utf8');

                        console.log(`‚úÖ Successfully bumped version to ${newVersion}`);

                        if (process.env.GITHUB_OUTPUT) {
                            fs.appendFileSync(process.env.GITHUB_OUTPUT, `newTag=v${newVersion}\n`);
                            fs.appendFileSync(process.env.GITHUB_OUTPUT, `newVersion=${newVersion}\n`);
                        }
                    } catch (error) {
                        console.error(`‚ùå Error: ${error.message}`);
                        process.exit(1);
                    }
                    EOF
                env:
                    COMMIT_MESSAGE: ${{ inputs.commit_message }}
                    FOLDER: ${{ inputs.folder }}
                    MAJOR_WORDING: 'major,breaking'
                    MINOR_WORDING: 'feature,feat'
                    PATCH_WORDING: 'patch,fixes,fix,misc,docs,refactor'

            -   name: 'Commit version bump'
                run: |
                    NEW_VERSION=$(cat $GITHUB_OUTPUT | grep newVersion | cut -d'=' -f2)
                    if [ -n "${{ inputs.folder }}" ]; then
                        COMMIT_MSG="[${{ inputs.folder }}] Bump Version to $NEW_VERSION [skip ci]"
                        git add "${{ inputs.folder }}/package.json"
                    else
                        COMMIT_MSG="Bump Version to $NEW_VERSION [skip ci]"
                        git add package.json
                    fi
                    git commit -m "$COMMIT_MSG"

            -   name: 'Create tag'
                if: ${{ !inputs['skip-tag'] }}
                run: |
                    NEW_TAG=$(cat $GITHUB_OUTPUT | grep newTag | cut -d'=' -f2)
                    git tag "$NEW_TAG"

            -   name: 'Show new version'
                run: echo "New version is ${{ steps.version-bump.outputs.newTag }}"

            -  name: 'Push changes'
               if: ${{ !inputs['skip-push'] }}
               run: |
                    git pull --rebase
                    git push https://x-access-token:${AUTH_TOKEN}@github.com/${{ github.repository }}.git HEAD:${{ github.ref_name }}
                    git push https://x-access-token:${AUTH_TOKEN}@github.com/${{ github.repository }}.git --tags